function [ li ] = f_find_neigh_cracks( sub_pc, sub_i_profs, li_cracks )
%Description...
%   

n_pc = length(sub_pc);
li_1 = zeros(n_pc, 1);
li_2 = zeros(n_pc, 1);

% 1st phase
li_cracks_indices = find(li_cracks == 1, n_pc);
neighbouring_indices = find(diff(li_cracks_indices) == 1, length(li_cracks_indices));

li_1(li_cracks_indices(neighbouring_indices)) = 1;
li_1(li_cracks_indices(neighbouring_indices) + 1) = 1;

% 2nd phase
% Dimension of the point cloud
d = 2;

% number of points in the point cloud
pc_indices = 1:n_pc;
sub_pc_w_i = [sub_pc, (pc_indices)']; % point cloud with indices

% Radius of the local neighbourhood
rn = 0.15; % (metres) 

% query points 
Q = sub_pc(logical(li_1), 1:2);
q_indices = 1:length(Q(:,1));

% create kdtree seach object
ns = createns(sub_pc_w_i(:, 1:d));

% Find points in the neighbourhood
ins_neigh = rangesearch(ns, Q, rn);
% ins_neigh_size = size(ins_neigh);
% n_neigh = ins_neigh_size(1);

indices = zeros(n_pc, 1);
n_points_th = 6;
start_i = 1;

for i_q = q_indices
    if (sum(li_1(ins_neigh{i_q})) > n_points_th) && ...
            (sub)
        end_i = start_i + length(ins_neigh{i_q}) - 1;
        indices(start_i:end_i) = sub_pc_w_i(ins_neigh{i_q}, 6);
        start_i = end_i + 1;
    end
end

indices = unique(indices(indices>0));

li_2(indices) = 1;

li = double(li_1 & li_2);
end