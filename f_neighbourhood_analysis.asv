function [ li ] = f_neighbourhood_analysis( sub_pc, sub_i_profs, ...
    li_cand, rn, n_points_th,  )
%Description...
%

n_pc = length(sub_pc);

% Dimension of the point cloud
d = 2;

% query points
Q = sub_pc(logical(li_cand), 1:2);
q_indices = 1:length(Q(:,1));

% create kdtree seach object
ns = createns(sub_pc(:, 1:d));

% Find points in the neighbourhood
ins_neigh = rangesearch(ns, Q, rn);

li_2 = false(n_pc, 1);

for i_q = q_indices
    search_profs = sub_i_profs(ins_neigh{i_q});
    q_prof = sub_i_profs(ins_neigh{i_q}(1));
    search_profs_unique = unique(search_profs);
    
    switch length(search_profs_unique)
        case 3
            other_profs = search_profs_unique([1,3]);
            inds1 = ins_neigh{i_q}(search_profs==other_profs(1));
            inds2 = ins_neigh{i_q}(search_profs==other_profs(2));
            if (sum(li_cand(inds1)) > n_points_th) || (sum(li_cand(inds2)) > n_points_th)
                inds = ins_neigh{i_q}(search_profs~=q_prof);
                li_2(inds) = true;
            end
        case 2
            switch q_prof == search_profs_unique(2)
                case true
                    other_prof = search_profs_unique(1);
                otherwise
                    other_prof = search_profs_unique(2);
            end
            inds1 = ins_neigh{i_q}(search_profs==other_prof);
            if sum(li_cand(inds1)) > n_points_th
                inds = ins_neigh{i_q}(search_profs~=q_prof);
                li_2(inds) = true;
            end
        otherwise
            if length(search_profs_unique) ~= 1
                
            end
    end
end

li = li_cand & li_2;

end